import React, { useState } from 'react';
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { supabase } from '@/integrations/supabase/client';
import { FileText, Upload, Download, Trash2, Eye } from 'lucide-react';
import TimeUtils from '@/lib/timeUtils';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { UploadDocumentDialog } from '@/components/documents/UploadDocumentDialog';
import { FileViewer } from '@/components/documents/FileViewer';
import { toast } from 'sonner';
interface DocumentsTabProps {
  caseId: string;
}
export const DocumentsTab: React.FC<DocumentsTabProps> = ({
  caseId
}) => {
  const [showUploadDialog, setShowUploadDialog] = useState(false);
  const [viewingDocument, setViewingDocument] = useState<any>(null);
  const queryClient = useQueryClient();

  const getDocTypeBadges = (doc: any) => {
    const primaryRaw: string | null = doc?.primary_document_type || doc?.folder_name || null;
    let subRaw: string | null = doc?.sub_document_type || null;

    // Fallback for older rows: try to infer from webdav_path generated by generateStoragePath
    // Format: Clients/{client}/Cases/{case}/{primary}/{sub}/{file}
    const pathCandidate = (doc?.webdav_path && typeof doc.webdav_path === 'string')
      ? doc.webdav_path
      : (doc?.file_url && typeof doc.file_url === 'string' ? doc.file_url : null);

    if (!subRaw && pathCandidate) {
      const parts = pathCandidate.split('/');
      const casesIdx = parts.indexOf('Cases');
      if (casesIdx >= 0) {
        const inferredSub = parts[casesIdx + 3];
        if (inferredSub) subRaw = inferredSub;
      }
    }

    const pretty = (value: string) => value.replace(/_/g, ' ');

    return {
      primary: primaryRaw ? pretty(primaryRaw) : null,
      sub: subRaw ? pretty(subRaw) : null,
    };
  };
  const {
    data: documents,
    isLoading
  } = useQuery({
    queryKey: ['uploaded-documents', caseId],
    queryFn: async () => {
      const {
        data,
        error
      } = await supabase.from('documents').select('*, profiles(full_name)').eq('case_id', caseId).order('uploaded_at', {
        ascending: false
      });
      if (error) throw error;
      // Filter out documents without complete data
      return data?.filter(doc => 
        doc.file_name && 
        doc.file_url && 
        doc.file_size && 
        doc.uploaded_at
      ) || [];
    }
  });
  const {
    data: legalkartDocuments
  } = useQuery({
    queryKey: ['legalkart-documents', caseId],
    queryFn: async () => {
      const {
        data
      } = await supabase.from('legalkart_documents' as any).select('*').eq('case_id', caseId).order('document_filed', {
        ascending: false
      });
      return data || [];
    }
  });
  const deleteDocument = useMutation({
    mutationFn: async (documentId: string) => {
      const {
        error
      } = await supabase.from('documents').delete().eq('id', documentId);
      if (error) throw error;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({
        queryKey: ['case-documents', caseId]
      });
      toast.success('Document deleted successfully');
    },
    onError: () => {
      toast.error('Failed to delete document');
    }
  });
  const handleDownload = async (document: any) => {
    try {
      const {
        data,
        error
      } = await supabase.storage.from('documents').download(document.file_url);
      if (error) throw error;
      const url = URL.createObjectURL(data);
      const a = document.createElement('a');
      a.href = url;
      a.download = document.file_name;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      toast.success('Document downloaded');
    } catch (error) {
      toast.error('Failed to download document');
    }
  };
  const formatFileSize = (bytes: number) => {
    if (!bytes) return '-';
    const kb = bytes / 1024;
    if (kb < 1024) return `${kb.toFixed(1)} KB`;
    return `${(kb / 1024).toFixed(1)} MB`;
  };
  const handleUploadSuccess = () => {
    queryClient.invalidateQueries({
      queryKey: ['uploaded-documents', caseId]
    });
    toast.success('Document uploaded successfully');
    setShowUploadDialog(false);
  };
  return <div className="space-y-6">
      {/* Create Document Upload Form */}
      <div className="p-4 rounded-lg bg-slate-50">
        
        <Button onClick={() => setShowUploadDialog(true)}>
          <Upload className="w-4 h-4 mr-2" />
          Upload Document
        </Button>
      </div>

      {/* Documents List */}
      <div className="space-y-3">
        {isLoading ? <div className="text-center py-8">
            <p className="text-muted-foreground">Loading documents...</p>
          </div> : documents && documents.length > 0 ? documents.map((doc: any) => <div key={doc.id} className="flex items-start justify-between p-4 border border-border rounded-lg hover:bg-muted/30 transition-colors">
              <div className="flex items-start gap-3 flex-1">
                <FileText className="w-5 h-5 text-primary mt-1" />
                <div className="flex-1">
                  {(() => {
                    const { primary, sub } = getDocTypeBadges(doc);
                    return (
                  <div className="flex items-center gap-2 flex-wrap">
                    <p className="font-medium">{doc.file_name}</p>
                    {primary && (
                      <Badge variant="default" className="text-xs">
                        {primary}
                      </Badge>
                    )}
                    {sub && (
                      <Badge variant="outline" className="text-xs bg-accent/50">
                        {sub}
                      </Badge>
                    )}
                  </div>
                    );
                  })()}
                  <p className="text-sm text-muted-foreground">
                    {formatFileSize(doc.file_size)} â€¢ {doc.uploaded_at ? TimeUtils.formatDate(doc.uploaded_at, 'dd/MM/yyyy') : 'N/A'}
                  </p>
                  {doc.notes && <p className="text-sm text-muted-foreground mt-1">{doc.notes}</p>}
                  <div className="text-xs text-muted-foreground mt-1">
                    Uploaded by {doc.profiles?.full_name || 'Unknown'}
                  </div>
                </div>
              </div>
              <div className="flex gap-2">
                <Button variant="ghost" size="sm" onClick={() => setViewingDocument(doc)} title="View">
                  <Eye className="w-4 h-4" />
                </Button>
                <Button variant="ghost" size="sm" onClick={() => handleDownload(doc)} title="Download">
                  <Download className="w-4 h-4" />
                </Button>
                <Button variant="ghost" size="sm" onClick={() => deleteDocument.mutate(doc.id)} title="Delete">
                  <Trash2 className="w-4 h-4 text-destructive" />
                </Button>
              </div>
            </div>) : <div className="text-center py-8">
            <p className="text-muted-foreground">No documents yet. Upload your first document above.</p>
          </div>}
      </div>

      {/* Legalkart Documents */}
      {legalkartDocuments && legalkartDocuments.length > 0 && <div>
          <h3 className="text-lg font-semibold mb-4">Court Documents (Legalkart)</h3>
          <div className="space-y-2">
            {legalkartDocuments.map((doc: any) => <div key={doc.id} className="flex items-center gap-3 p-4 border border-border rounded-lg hover:bg-muted/30 transition-colors">
                <FileText className="w-5 h-5 text-primary" />
                <div>
                  <p className="font-medium">{doc.document_filed || 'Court Document'}</p>
                  <p className="text-sm text-muted-foreground">
                    Filed: {doc.document_filed_date ? TimeUtils.formatDate(doc.document_filed_date, 'dd/MM/yyyy') : 'Date not available'}
                  </p>
                </div>
              </div>)}
          </div>
        </div>}

      {/* Upload Document Dialog */}
      <UploadDocumentDialog open={showUploadDialog} onClose={() => setShowUploadDialog(false)} caseId={caseId} onUploadSuccess={handleUploadSuccess} />
      
      {/* File Viewer */}
      <FileViewer
        open={!!viewingDocument}
        onClose={() => setViewingDocument(null)}
        document={viewingDocument}
      />
    </div>;
};